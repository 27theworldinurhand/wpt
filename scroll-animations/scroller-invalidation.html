<!DOCTYPE html>
<meta charset="utf-8">
<title>ScrollTimeline current time algorithm</title>
<link rel="help" href="https://wicg.github.io/scroll-animations/#current-time-algorithm">
<script src="/resources/testharness.js"></script>
<script src="/resources/testharnessreport.js"></script>
<script src="/web-animations/testcommon.js"></script>
<style>
  .scroller {
    overflow: auto;
    height: 100px;
    width: 100px;
  }
  .contents {
    height: 1000px;
    width: 100%;
  }
</style>
<div id="log"></div>

<script>
'use strict';
function createScroller(test) {
  var scroller = createDiv(test);
  scroller.innerHTML = "<div class='contents' id='contents'></div>";
  scroller.classList.add('scroller');
  return scroller;
}

function createScrollTimeline(test) {
  return new ScrollTimeline({
    scrollSource: createScroller(test),
    timeRange: 1000
  });
}

function createScrollLinkedAnimation(test, timeline) {
  if(timeline === undefined)
    timeline = createScrollTimeline(test);
  const DURATION = 1000; // ms
  const KEYFRAMES = { opacity: [1, 0] };
  return new Animation(
    new KeyframeEffect(createDiv(test), KEYFRAMES, DURATION), timeline);
}

promise_test(async t => {
  const animation = createScrollLinkedAnimation(t);
  const scroller = animation.timeline.scrollSource;
  const maxScroll = scroller.scrollHeight - scroller.clientHeight;
  scroller.scrollTop = 0.2 * maxScroll;

  animation.play();

  await animation.ready;
  // Change scroller content size.
  document.getElementById("contents").style.height = "2000px";
  // Trigger layout.
  scroller.scrollHeight;

  const newTime = 94.736; // scroller.scrollTop /
                          // (scroller.scrollHeight - scroller.clientHeight)
                          // * timeRange;
  // TODO(crbug.com/944449): After scroll offset snapshotting is implemented,
  // scroll timeline current time, animation current time and effect local
  // time will be updated on the same frame (which in this case will be the
  // next frame).
  assert_times_equal(animation.currentTime, newTime,
    'Animation current time is updated after scroller invalidation.');

  await waitForNextFrame();
  assert_times_equal(
    animation.effect.getComputedTiming().localTime, newTime,
    'Effect local time is updated after scroller invalidation.');
}, 'Animation current time and effect local time are updated after scroller ' +
   'content size changes.');

promise_test(async t => {
  const animation = createScrollLinkedAnimation(t);
  const scroller = animation.timeline.scrollSource;
  const maxScroll = scroller.scrollHeight - scroller.clientHeight;
  scroller.scrollTop = 0.2 * maxScroll;

  animation.play();

  await animation.ready;
  // Change scroller size.
  scroller.style.height = "200px";
  // Trigger layout.
  scroller.scrollHeight;

  const newTime = 225; // scroller.scrollTop /
                       // (scroller.scrollHeight - scroller.clientHeight)
                       // * timeRange;
  // TODO(crbug.com/944449): After scroll offset snapshotting is implemented,
  // scroll timeline current time, animation current time and effect local
  // time will be updated on the same frame (which in this case will be the
  // next frame).
  assert_times_equal(animation.currentTime, newTime,
    'Animation current time is updated after scroller invalidation.');

  await waitForNextFrame();
  assert_times_equal(
    animation.effect.getComputedTiming().localTime, newTime,
    'Effect local time is updated after scroller invalidation.');
}, 'Animation current time and effect local time are updated after scroller ' +
   'size changes.');

</script>
